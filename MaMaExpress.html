<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MaMaExpress - Association MaMaMa</title>
    <link rel="stylesheet" href="MaMaStyle.css">
</head>
<body>
    <div class="header">
        <img src="https://images.squarespace-cdn.com/content/v1/5ec8595ff51b0459bf5c59d8/d36a9706-f7a7-444a-9a13-fb2ee27373e8/mamama_logo.png?format=1500w" alt="Association MaMaMa" class="logo">
    </div>
    <div class="container">
        <h1>MaMaExpress</h1>
        
        <div class="input-section">
            <div class="address-input">
                <h3>PMI √† visiter :</h3>
                <div class="pmi-controls">
                    <input type="text" id="searchPmi" placeholder="Rechercher une PMI..." class="search-input">
                    <div class="select-buttons">
                        <button id="selectAll" class="select-button">Tout s√©lectionner</button>
                        <button id="deselectAll" class="select-button">Tout d√©s√©lectionner</button>
                    </div>
                </div>
                <div id="pmiList" class="pmi-list">
                    <p style="color: #666;">Chargement des donn√©es...</p>
                </div>
                <div id="selectedPmiList" style="margin-top: 15px; padding: 10px; background-color: #f0f0f0; border-radius: 5px; display: none;">
                    <strong id="selectedPmiTitle" style="display: block; margin-bottom: 8px; color: #2C3E50;">PMI s√©lectionn√©es :</strong>
                    <div id="selectedPmiItems" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; color: #555;"></div>
                </div>
            </div>
            <button id="calculateButton" class="calculate-button">Calculer le meilleur itin√©raire</button>
        </div>

        <div id="results" class="results-section" style="display: none;">
            <div class="routes-list">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0;">Itin√©raire optimis√©</h3>
                    <div id="googleMapsButton"></div>
                </div>
                <div id="routes"></div>
            </div>
        </div>
    </div>
    <div class="footer">
        Pour toute id√©e d'am√©lioration, contactez Natacha : <a href="mailto:digital@asso-mamama.fr">digital@asso-mamama.fr</a>
    </div>

    <!-- Fichiers de donn√©es JavaScript (g√©n√©r√©s depuis les CSV) -->
    <script src="pmi_addresses.js"></script>
    <script src="pmi_durees.js"></script>

    <script>
        // Stockage des PMI charg√©es depuis les fichiers JavaScript
        let allPmis = [];
        let filteredPmis = [];
        
        // Stockage des dur√©es entre toutes les paires de PMI
        // Cl√© : "adresse1|adresse2", Valeur : dur√©e en minutes
        let dureesMap = new Map();
        
        // Stockage persistant des indices de PMI s√©lectionn√©es (m√™me si elles ne sont pas dans le filtre actuel)
        let selectedPmiIndices = new Set();

        /**
         * Initialise les donn√©es depuis les variables JavaScript
         */
        function initializeFromJS() {
            // V√©rifier que les variables sont disponibles
            if (typeof PMI_ADDRESSES === 'undefined') {
                console.error('PMI_ADDRESSES non d√©fini. V√©rifiez que pmi_addresses.js est charg√©.');
                document.getElementById('pmiList').innerHTML = 
                    '<p style="color: red;">‚ùå Erreur : Fichier pmi_addresses.js non charg√©</p>';
                return;
            }
            
            if (typeof PMI_DUREES === 'undefined') {
                console.error('PMI_DUREES non d√©fini. V√©rifiez que pmi_durees.js est charg√©.');
                return;
            }
            
            // Initialiser l'adresse MaMaMa depuis la variable JavaScript globale
            if (typeof MAMAMA_ADDRESS === 'undefined') {
                MAMAMA_ADDRESS = "rue Louis Girard, Aubervilliers";
            }
            
            // Initialiser les PMI
            allPmis = PMI_ADDRESSES.map(pmi => ({
                nom: pmi.nom,
                address: pmi.address,
                lat: pmi.lat,
                lng: pmi.lng
            }));
            
            filteredPmis = [...allPmis];
            displayPmis();
            updateSelectedCount();
            
            // Initialiser les dur√©es
            dureesMap.clear();
            for (const [key, value] of Object.entries(PMI_DUREES)) {
                dureesMap.set(key, value);
            }
        }

        /**
         * Affiche la liste des PMI avec des checkboxes
         * Pr√©serve les s√©lections existantes en utilisant le Set global
         */
        function displayPmis() {
            const pmiListDiv = document.getElementById('pmiList');
            
            // Synchroniser le Set global avec les checkboxes actuelles avant de r√©afficher
            document.querySelectorAll('.pmi-checkbox:checked').forEach(cb => {
                const idx = parseInt(cb.dataset.index);
                selectedPmiIndices.add(idx);
            });
            
            pmiListDiv.innerHTML = '';
            
            if (filteredPmis.length === 0) {
                pmiListDiv.innerHTML = '<p>Aucune PMI trouv√©e</p>';
                updateSelectedCount();
                return;
            }

            filteredPmis.forEach((pmi, index) => {
                const pmiIndex = allPmis.indexOf(pmi);
                const isChecked = selectedPmiIndices.has(pmiIndex);
                
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'pmi-item';
                
                const checkboxInput = document.createElement('input');
                checkboxInput.type = 'checkbox';
                checkboxInput.id = `pmi-${index}`;
                checkboxInput.dataset.index = pmiIndex;
                checkboxInput.className = 'pmi-checkbox';
                checkboxInput.checked = isChecked;
                
                const label = document.createElement('label');
                label.htmlFor = `pmi-${index}`;
                label.innerHTML = `
                    <strong>${pmi.nom}</strong><br>
                    <span class="pmi-address">${pmi.address}</span>
                `;
                
                checkboxDiv.appendChild(checkboxInput);
                checkboxDiv.appendChild(label);
                pmiListDiv.appendChild(checkboxDiv);
            });
            
            // Utiliser la d√©l√©gation d'√©v√©nements sur le conteneur parent
            // Cela garantit que les √©v√©nements fonctionnent m√™me si les √©l√©ments sont recr√©√©s
            pmiListDiv.addEventListener('change', function(e) {
                if (e.target && e.target.classList.contains('pmi-checkbox')) {
                    const idx = parseInt(e.target.dataset.index);
                    if (e.target.checked) {
                        selectedPmiIndices.add(idx);
                    } else {
                        selectedPmiIndices.delete(idx);
                    }
                    updateSelectedCount();
                }
            });
            
            // √âgalement √©couter les clics sur le conteneur pour capturer les clics sur les labels
            pmiListDiv.addEventListener('click', function(e) {
                // Si on clique sur un label, trouver la checkbox associ√©e
                if (e.target.tagName === 'LABEL' || e.target.closest('label')) {
                    const label = e.target.tagName === 'LABEL' ? e.target : e.target.closest('label');
                    const checkboxId = label.getAttribute('for');
                    if (checkboxId) {
                        const checkbox = document.getElementById(checkboxId);
                        if (checkbox && checkbox.classList.contains('pmi-checkbox')) {
                            // Attendre que le navigateur change l'√©tat de la checkbox
                            setTimeout(() => {
                                const idx = parseInt(checkbox.dataset.index);
                                if (checkbox.checked) {
                                    selectedPmiIndices.add(idx);
                                } else {
                                    selectedPmiIndices.delete(idx);
                                }
                                updateSelectedCount();
                            }, 10);
                        }
                    }
                }
            });
            
            updateSelectedCount();
        }

        /**
         * Filtre les PMI selon le terme de recherche
         */
        function filterPmis(searchTerm) {
            // V√©rifier que les PMI sont charg√©es
            if (allPmis.length === 0) {
                return;
            }
            
            const term = (searchTerm || '').toLowerCase().trim();
            if (term === '') {
                filteredPmis = [...allPmis];
            } else {
                filteredPmis = allPmis.filter(pmi => {
                    const nomMatch = pmi.nom && pmi.nom.toLowerCase().includes(term);
                    const addressMatch = pmi.address && pmi.address.toLowerCase().includes(term);
                    return nomMatch || addressMatch;
                });
            }
            
            displayPmis();
        }

        /**
         * Met √† jour le compteur de PMI s√©lectionn√©es et affiche la liste
         * Utilise le Set global pour compter toutes les s√©lections, m√™me celles non visibles
         */
        function updateSelectedCount() {
            const selected = selectedPmiIndices.size;
            
            // Afficher la liste des PMI s√©lectionn√©es
            const selectedPmiListDiv = document.getElementById('selectedPmiList');
            const selectedPmiTitle = document.getElementById('selectedPmiTitle');
            const selectedPmiItemsUl = document.getElementById('selectedPmiItems');
            
            if (selected === 0) {
                selectedPmiListDiv.style.display = 'none';
            } else {
                selectedPmiListDiv.style.display = 'block';
                // Mettre √† jour le titre avec le nombre de PMI s√©lectionn√©es
                selectedPmiTitle.textContent = `${selected} PMI s√©lectionn√©e(s) :`;
                selectedPmiItemsUl.innerHTML = '';
                
                // Trier les indices pour un affichage coh√©rent
                const sortedIndices = Array.from(selectedPmiIndices).sort((a, b) => a - b);
                
                sortedIndices.forEach(index => {
                    if (allPmis[index]) {
                        const div = document.createElement('div');
                        div.style.padding = '5px';
                        div.style.fontSize = '14px';
                        const pmi = allPmis[index];
                        div.textContent = pmi.nom || pmi.address;
                        selectedPmiItemsUl.appendChild(div);
                    }
                });
            }
        }

        /**
         * Normalise une adresse pour faciliter la correspondance
         * (enl√®ve les espaces multiples, convertit en majuscules, supprime "France", etc.)
         */
        function normalizeAddress(address) {
            if (!address) return '';
            return address.trim()
                .toUpperCase()
                .replace(/\s*,\s*FRANCE\s*$/i, '') // Enlever ", France" √† la fin
                .replace(/\s+/g, ' ')
                .replace(/[.,]/g, ' ') // Remplacer ponctuation par espaces
                .trim();
        }

        /**
         * Extrait les mots significatifs d'une adresse (rue, num√©ro, ville)
         */
        function extractSignificantWords(address) {
            const normalized = normalizeAddress(address);
            // Filtrer les mots courts et les mots communs non significatifs
            const stopWords = new Set(['DE', 'DU', 'DES', 'LA', 'LE', 'LES', 'ET', 'RUE', 'AVENUE', 'BOULEVARD', 'PLACE']);
            return normalized.split(/\s+/)
                .filter(w => w.length > 2 && !stopWords.has(w));
        }

        /**
         * V√©rifie si deux adresses correspondent (avec tol√©rance)
         */
        function addressesMatch(addr1, addr2) {
            if (!addr1 || !addr2) return false;
            
            const norm1 = normalizeAddress(addr1);
            const norm2 = normalizeAddress(addr2);
            
            // Correspondance exacte
            if (norm1 === norm2) return true;
            
            // Correspondance partielle (une contient l'autre, en ignorant les diff√©rences de format)
            const norm1Clean = norm1.replace(/[^A-Z0-9]/g, '');
            const norm2Clean = norm2.replace(/[^A-Z0-9]/g, '');
            if (norm1Clean.includes(norm2Clean) || norm2Clean.includes(norm1Clean)) {
                // V√©rifier qu'on a au moins quelques caract√®res en commun significatifs
                if (norm1Clean.length > 10 && norm2Clean.length > 10) return true;
            }
            
            // Correspondance par mots significatifs (au moins 2 mots significatifs en commun)
            const words1 = extractSignificantWords(addr1);
            const words2 = extractSignificantWords(addr2);
            const commonWords = words1.filter(w => words2.includes(w));
            
            // Pour les adresses courtes, accepter 2 mots en commun, sinon 3
            const minWords = (words1.length < 4 || words2.length < 4) ? 2 : 3;
            return commonWords.length >= minWords;
        }

        /**
         * R√©cup√®re l'ID d'une adresse depuis le mapping
         * @param {string} address - Adresse √† rechercher
         * @returns {number|null} ID de l'adresse ou null si non trouv√©e
         */
        function getAddressId(address) {
            if (!address || typeof PMI_ADDRESS_TO_ID === 'undefined') {
                return null;
            }
            // Recherche directe
            let id = PMI_ADDRESS_TO_ID[address];
            if (id !== undefined) {
                return id;
            }
            // Recherche dans les PMI_ADDRESSES si l'adresse correspond
            if (typeof PMI_ADDRESSES !== 'undefined') {
                for (const pmi of PMI_ADDRESSES) {
                    if (pmi.address === address) {
                        return pmi.id;
                    }
                }
            }
            // V√©rifier si c'est l'adresse MaMaMa
            if (typeof MAMAMA_ADDRESS !== 'undefined' && address === MAMAMA_ADDRESS) {
                return typeof MAMAMA_ID !== 'undefined' ? MAMAMA_ID : null;
            }
            return null;
        }

        /**
         * R√©cup√®re la dur√©e entre deux adresses depuis la map des dur√©es
         * Utilise les IDs pour la recherche, ce qui est plus rapide et fiable
         * @param {string} adresse1 - Premi√®re adresse
         * @param {string} adresse2 - Deuxi√®me adresse
         * @returns {number} Dur√©e en minutes, ou Infinity si non trouv√©e
         */
        function getDuree(adresse1, adresse2) {
            // Obtenir les IDs des adresses
            const id1 = getAddressId(adresse1);
            const id2 = getAddressId(adresse2);
            
            if (id1 === null || id2 === null) {
                return Infinity;
            }
            
            // Rechercher avec les IDs
            const key = `${id1}|${id2}`;
            const duree = dureesMap.get(key);
            
            return duree !== undefined ? duree : Infinity;
        }

        /**
         * Calcule l'ordre optimal des visites en utilisant l'algorithme du plus proche voisin
         * Utilise les dur√©es pr√©calcul√©es du CSV au lieu de l'API OSRM
         * Retourne l'ordre des indices des waypoints
         */
        async function calculateOptimalOrder(waypoints) {
            
            // V√©rifier que les dur√©es sont charg√©es
            if (dureesMap.size === 0) {
                throw new Error('Les dur√©es de trajet n\'ont pas √©t√© charg√©es. Veuillez recharger la page.');
            }
            
            // Construire la matrice de dur√©es pour les waypoints s√©lectionn√©s
            const n = waypoints.length;
            const dureesMatrix = [];
            let dureesManquantes = 0;
            const missingPairs = [];
            
            for (let i = 0; i < n; i++) {
                dureesMatrix[i] = [];
                for (let j = 0; j < n; j++) {
                    if (i === j) {
                        dureesMatrix[i][j] = 0;
                    } else {
                        const duree = getDuree(waypoints[i].address, waypoints[j].address);
                        dureesMatrix[i][j] = duree;
                        if (duree === Infinity) {
                            dureesManquantes++;
                            missingPairs.push({
                                from: waypoints[i].address,
                                to: waypoints[j].address,
                                fromName: waypoints[i].nom,
                                toName: waypoints[j].nom
                            });
                        }
                    }
                }
            }
            

            // Algorithme du plus proche voisin : toujours aller au point le plus proche non visit√©
            const visited = new Set([0]); // Commencer par le point de d√©part (index 0)
            const order = [0];
            
            while (visited.size < waypoints.length) {
                let minDuree = Infinity;
                let nextPoint = -1;
                const currentPoint = order[order.length - 1];
                
                // Trouver le point non visit√© avec la dur√©e minimale depuis le point actuel
                for (let i = 0; i < n; i++) {
                    if (!visited.has(i)) {
                        const duree = dureesMatrix[currentPoint][i];
                        if (duree < minDuree) {
                            minDuree = duree;
                            nextPoint = i;
                        }
                    }
                }
                
                if (nextPoint === -1 || minDuree === Infinity) {
                    // Si aucune dur√©e trouv√©e, prendre le prochain point non visit√©
                    for (let i = 0; i < n; i++) {
                        if (!visited.has(i)) {
                            nextPoint = i;
                            break;
                        }
                    }
                    if (nextPoint === -1) break;
                }
                
                visited.add(nextPoint);
                order.push(nextPoint);
            }
                
            // Am√©lioration avec l'algorithme 2-opt
            let amelioration = true;
            while (amelioration) {
                amelioration = false;
                const n = order.length;
                
                for (let i = 0; i < n - 2; i++) {
                    for (let j = i + 2; j < n - 1; j++) {
                        // Calculer le gain potentiel de l'inversion du segment [i+1 ... j]
                        // gain = d(i,i+1) + d(j,j+1) - d(i,j) - d(i+1,j+1)
                        const d_i_i1 = dureesMatrix[order[i]][order[i + 1]];
                        const d_j_j1 = dureesMatrix[order[j]][order[j + 1]];
                        const d_i_j = dureesMatrix[order[i]][order[j]];
                        const d_i1_j1 = dureesMatrix[order[i + 1]][order[j + 1]];
                        
                        // Ignorer si certaines dur√©es sont infinies
                        if (d_i_i1 === Infinity || d_j_j1 === Infinity || 
                            d_i_j === Infinity || d_i1_j1 === Infinity) {
                            continue;
                        }
                        
                        const gain = d_i_i1 + d_j_j1 - d_i_j - d_i1_j1;
                        
                        if (gain > 0) {
                            // Inverser le segment [i+1 ... j]
                            let start = i + 1;
                            let end = j;
                            while (start < end) {
                                const temp = order[start];
                                order[start] = order[end];
                                order[end] = temp;
                                start++;
                                end--;
                            }
                            amelioration = true;
                            break; // Sortir de la boucle j
                        }
                    }
                    if (amelioration) break; // Sortir de la boucle i
                }
            }
            
            // Calculer la dur√©e totale de l'itin√©raire (sans le retour pour l'instant)
            let dureeTotale = 0;
            for (let i = 0; i < order.length - 1; i++) {
                const duree = dureesMatrix[order[i]][order[i + 1]];
                if (duree !== Infinity) {
                    dureeTotale += duree;
                }
            }
            
            return order;
        }

        /**
         * Fonction principale : calcule et affiche l'itin√©raire optimis√©
         */
        async function calculateRoutes() {
            // Afficher imm√©diatement l'indicateur de chargement
            const calculateButton = document.getElementById('calculateButton');
            const originalButtonText = calculateButton ? calculateButton.textContent : 'Calculer le meilleur itin√©raire';
            if (calculateButton) {
                calculateButton.disabled = true;
                calculateButton.textContent = '‚è≥ Calcul en cours...';
                calculateButton.style.opacity = '0.7';
                calculateButton.style.cursor = 'not-allowed';
            }
            
            document.getElementById('results').style.display = 'none';

            // R√©cup√©rer les PMI s√©lectionn√©es depuis le Set global
            const selectedIndices = Array.from(selectedPmiIndices);
            const selectedPmis = selectedIndices.map(index => allPmis[index]);
            
            if (selectedPmis.length === 0) {
                // Restaurer le bouton
                if (calculateButton) {
                    calculateButton.disabled = false;
                    calculateButton.textContent = originalButtonText;
                    calculateButton.style.opacity = '1';
                    calculateButton.style.cursor = 'pointer';
                }
                alert('Veuillez s√©lectionner au moins une PMI');
                return;
            }

            // Petit d√©lai pour permettre au navigateur d'afficher l'indicateur
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                // Pr√©parer les locations (point de d√©part + PMI s√©lectionn√©es)
                // On utilise les dur√©es pr√©calcul√©es, pas besoin de g√©ocoder
                const locations = [{
                    nom: 'MaMaMa (D√©part)',
                    address: MAMAMA_ADDRESS,
                    lat: null,
                    lng: null
                }];
                
                for (const pmi of selectedPmis) {
                    locations.push({
                        nom: pmi.nom,
                        address: pmi.address,
                        lat: pmi.lat,
                        lng: pmi.lng
                    });
                }

                // Calculer l'ordre optimal de visite
                const optimalOrder = await calculateOptimalOrder(locations);

                // Afficher l'itin√©raire dans l'ordre optimis√©
                const orderedWaypoints = optimalOrder.map(index => locations[index]);
                displayRoute(orderedWaypoints);
                
                // Restaurer le bouton apr√®s succ√®s
                if (calculateButton) {
                    calculateButton.disabled = false;
                    calculateButton.textContent = originalButtonText;
                    calculateButton.style.opacity = '1';
                    calculateButton.style.cursor = 'pointer';
                }
                
            } catch (error) {
                console.error('Erreur:', error);
                alert('Erreur lors du calcul. V√©rifiez que les adresses sont correctes.');
                
                // Restaurer le bouton apr√®s erreur
                if (calculateButton) {
                    calculateButton.disabled = false;
                    calculateButton.textContent = originalButtonText;
                    calculateButton.style.opacity = '1';
                    calculateButton.style.cursor = 'pointer';
                }
            }
        }

        /**
         * Affiche l'itin√©raire optimis√© sous forme de liste num√©rot√©e
         */
        function displayRoute(waypoints) {
            const routesDiv = document.getElementById('routes');
            routesDiv.innerHTML = '';

            const routeDiv = document.createElement('div');
            routeDiv.className = 'route';
            
            // Calculer la dur√©e totale de l'itin√©raire (d√©part ‚Üí visites ‚Üí retour)
            let dureeTotale = 0;
            // Dur√©es entre les points de l'itin√©raire
            for (let i = 0; i < waypoints.length - 1; i++) {
                const duree = getDuree(waypoints[i].address, waypoints[i + 1].address);
                if (duree !== Infinity) {
                    dureeTotale += duree;
                }
            }
            // Ajouter le retour du dernier point visit√© au point de d√©part
            const dernierPoint = waypoints[waypoints.length - 1];
            const dureeRetour = getDuree(dernierPoint.address, waypoints[0].address);
            if (dureeRetour !== Infinity) {
                dureeTotale += dureeRetour;
            }
            
            // Construire la liste : d√©part ‚Üí visites ‚Üí retour
            let html = `<h4>Itin√©raire optimis√©</h4>`;
            if (dureeTotale > 0) {
                html += `<p><strong>Dur√©e totale estim√©e : ${dureeTotale.toFixed(1)} minutes (${(dureeTotale / 60).toFixed(1)} heures)</strong></p>`;
                // Ajouter une mention sur les dur√©es estim√©es
                html += `<p style="margin-top: 10px; padding: 12px; background-color: #f5f5f5; border-left: 3px solid #666; color: #555; font-size: 0.9em; line-height: 1.5;">
                    <strong>Note :</strong> Les dur√©es indiqu√©es sont des estimations bas√©es sur des conditions de circulation normales. Elles ne prennent pas en compte les bouchons, les accidents, les conditions m√©t√©orologiques ou d'autres √©v√©nements pouvant affecter le trafic. Les temps de trajet r√©els peuvent varier.
                </p>`;
            }
            html += `<ol><li><strong>${waypoints[0].address}</strong> (D√©part)</li>`;
            // Afficher les points visit√©s (sauf le premier qui est le d√©part)
            for (let i = 1; i < waypoints.length; i++) {
                const displayName = waypoints[i].nom 
                    ? `${waypoints[i].nom} - ${waypoints[i].address}` 
                    : waypoints[i].address;
                html += `<li>${displayName}</li>`;
            }
            // Afficher le retour seulement si on a visit√© au moins un point
            if (waypoints.length > 1) {
                html += `<li><strong>${waypoints[0].address}</strong> (Retour)</li>`;
            }
            html += `</ol>`;
            
            routeDiv.innerHTML = html;
            routesDiv.appendChild(routeDiv);
            
            // Ajouter le bouton Google Maps √† c√¥t√© du titre
            const googleMapsButtonDiv = document.getElementById('googleMapsButton');
            googleMapsButtonDiv.innerHTML = '';
            if (waypoints.length > 1) {
                const { url: googleMapsUrl, limited } = buildGoogleMapsUrl(waypoints);
                const mapsLink = document.createElement('a');
                mapsLink.href = googleMapsUrl;
                mapsLink.target = '_blank';
                mapsLink.style.cssText = 'display: inline-block; padding: 10px 20px; background-color: #4285f4; color: white; text-decoration: none; border-radius: 5px; font-weight: bold;';
                if (limited) {
                    mapsLink.textContent = 'üó∫Ô∏è Voir l\'itin√©raire (9 premi√®res adresses)';
                } else {
                    mapsLink.textContent = 'üó∫Ô∏è Voir l\'itin√©raire sur Google Maps';
                }
                googleMapsButtonDiv.appendChild(mapsLink);
            }
            
            document.getElementById('results').style.display = 'block';
        }

        /**
         * Construit l'URL Google Maps pour l'itin√©raire en voiture
         * Google Maps limite √† 10 √©tapes au total (1 d√©part + 9 waypoints + 1 destination)
         * @param {Array} waypoints - Liste des points dans l'ordre optimis√©
         * @returns {Object} {url: string, limited: boolean} - URL Google Maps et indication si limit√©
         */
        function buildGoogleMapsUrl(waypoints) {
            if (waypoints.length === 0) return { url: '', limited: false };
            
            // Point de d√©part (MaMaMa)
            const origin = encodeURIComponent(waypoints[0].address);
            
            // Point de destination (retour √† MaMaMa)
            const destination = encodeURIComponent(waypoints[0].address);
            
            // Waypoints : limiter √† 9 maximum (Google Maps limite √† 10 √©tapes au total)
            // On prend waypoints[1] √† waypoints[9] (9 waypoints max)
            const maxWaypoints = 9;
            const waypointsList = [];
            const limited = waypoints.length > 10; // Plus de 10 points au total (d√©part + 9 waypoints + destination)
            
            for (let i = 1; i < waypoints.length && waypointsList.length < maxWaypoints; i++) {
                waypointsList.push(encodeURIComponent(waypoints[i].address));
            }
            const waypointsParam = waypointsList.join('|');
            
            // Construire l'URL Google Maps Directions
            let url = `https://www.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}&travelmode=driving`;
            if (waypointsParam) {
                url += `&waypoints=${waypointsParam}`;
            }
            
            return { url, limited };
        }

        /**
         * S√©lectionne toutes les PMI visibles (filtr√©es)
         */
        function selectAllVisible() {
            document.querySelectorAll('.pmi-checkbox').forEach(cb => {
                const idx = parseInt(cb.dataset.index);
                cb.checked = true;
                selectedPmiIndices.add(idx);
            });
            updateSelectedCount();
        }

        /**
         * D√©s√©lectionne toutes les PMI visibles (filtr√©es)
         */
        function deselectAllVisible() {
            document.querySelectorAll('.pmi-checkbox').forEach(cb => {
                const idx = parseInt(cb.dataset.index);
                cb.checked = false;
                selectedPmiIndices.delete(idx);
            });
            updateSelectedCount();
        }

        /**
         * Attache les √©v√©nements aux √©l√©ments de l'interface
         */
        function attachEventListeners() {
            const calculateButton = document.getElementById('calculateButton');
            const searchPmi = document.getElementById('searchPmi');
            const selectAll = document.getElementById('selectAll');
            const deselectAll = document.getElementById('deselectAll');
            if (calculateButton) {
                calculateButton.addEventListener('click', function(e) {
                    calculateRoutes();
                });
            } else {
                console.error('Bouton calculateButton non trouv√© dans le DOM');
            }
            
            if (searchPmi) {
                // √âcouter l'√©v√©nement input pour la recherche en temps r√©el
                searchPmi.addEventListener('input', function(e) {
                    filterPmis(e.target.value);
                });
            }
            
            if (selectAll) {
                selectAll.addEventListener('click', selectAllVisible);
            }
            
            if (deselectAll) {
                deselectAll.addEventListener('click', deselectAllVisible);
            }
            
            // Initialiser les donn√©es au chargement de la page
            if (typeof PMI_ADDRESSES !== 'undefined' && typeof PMI_DUREES !== 'undefined') {
                initializeFromJS();
            } else {
                // Attendre que les scripts soient charg√©s
                window.addEventListener('load', function() {
                    setTimeout(() => {
                        if (typeof PMI_ADDRESSES !== 'undefined' && typeof PMI_DUREES !== 'undefined') {
                            initializeFromJS();
                        } else {
                            console.error('Donn√©es non disponibles apr√®s chargement');
                            document.getElementById('pmiList').innerHTML = 
                                '<p style="color: red;">‚ùå Erreur : Les fichiers de donn√©es JavaScript ne sont pas charg√©s. V√©rifiez que pmi_addresses.js et pmi_durees.js sont pr√©sents.</p>';
                        }
                    }, 100);
                });
            }
        }
        
        // Attacher les √©v√©nements - le script est √† la fin du body donc le DOM est d√©j√† pr√™t
        attachEventListeners();
    </script>
</body>
</html> 