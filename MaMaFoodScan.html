<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MaMaOptiTruc - Association MaMaMa</title>
    <link rel="stylesheet" href="MaMaStyle.css">
</head>
<body>
    <div class="header">
        <img src="https://images.squarespace-cdn.com/content/v1/5ec8595ff51b0459bf5c59d8/d36a9706-f7a7-444a-9a13-fb2ee27373e8/mamama_logo.png?format=1500w" alt="Association MaMaMa" class="logo">
    </div>
    <div class="container">
        <h1>MaMaOptiTruc</h1>
        <div class="instructions">
            <ol>
                <li>Entrez les adresses à visiter (une par ligne)</li>
                <li>Cliquez sur "Calculer le meilleur itinéraire"</li>
                <li>Visualisez l'itinéraire optimisé</li>
            </ol>
        </div>
        
        <div class="input-section">
            <div class="address-input">
                <h3>Adresses à visiter :</h3>
                <textarea id="addresses" rows="10" placeholder="Entrez une adresse par ligne&#10;Exemple :&#10;10 rue de la Paix, Paris&#10;15 avenue des Champs-Élysées, Paris"></textarea>
            </div>
            <button id="calculateButton" class="calculate-button">Calculer le meilleur itinéraire</button>
        </div>

        <div id="logs" class="logs-section" style="display: none;">
            <h3>Calcul en cours :</h3>
            <div id="logContent" class="log-content"></div>
        </div>

        <div id="results" class="results-section" style="display: none;">
            <div class="routes-list">
                <h3>Itinéraire optimisé :</h3>
                <div id="routes"></div>
            </div>
        </div>
    </div>
    <div class="footer">
        Pour toute idée d'amélioration, contactez Natacha : <a href="mailto:digital@asso-mamama.fr">digital@asso-mamama.fr</a>
    </div>

    <script>
        const MAMAMA_ADDRESS = "23 rue Madeleine Vionnet, Aubervilliers, France";

        function addLog(message) {
            const logContent = document.getElementById('logContent');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = message;
            logContent.appendChild(logEntry);
            logContent.scrollTop = logContent.scrollHeight;
        }

        async function geocodeAddress(address) {
            addLog(`Recherche des coordonnées pour : ${address}`);
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`);
            const data = await response.json();
            if (data && data[0]) {
                addLog(`✓ Coordonnées trouvées : ${data[0].lat}, ${data[0].lon}`);
                return {
                    address: address,
                    lat: parseFloat(data[0].lat),
                    lng: parseFloat(data[0].lon)
                };
            }
            throw new Error(`Adresse non trouvée: ${address}`);
        }

        async function calculateRoute(waypoints) {
            addLog('Calcul de l\'itinéraire optimal...');
            
            // Fonction pour formater les coordonnées
            function formatCoordinate(coord) {
                return Number(coord).toFixed(6);
            }

            try {
                // 1. Calculer la matrice de distance entre tous les points (sans le point de retour)
                addLog('Calcul des distances entre les points...');
                const coordinates = waypoints.slice(0, -1).map(wp => `${formatCoordinate(wp.lng)},${formatCoordinate(wp.lat)}`).join(';');
                const matrixResponse = await fetch(`https://router.project-osrm.org/table/v1/driving/${coordinates}?sources=0&destinations=all`);
                const matrixData = await matrixResponse.json();
                
                if (matrixData.code !== 'Ok') {
                    throw new Error(`Erreur matrice de distance : ${matrixData.code}`);
                }

                // 2. Trouver l'ordre optimal en utilisant l'algorithme du plus proche voisin
                addLog('Calcul de l\'ordre optimal...');
                const distances = matrixData.durations[0];
                const visited = new Set([0]); // Commencer par le point de départ (index 0)
                const order = [0];
                
                while (visited.size < waypoints.length - 1) { // -1 car on ne compte pas le point de retour
                    let minDistance = Infinity;
                    let nextPoint = -1;
                    
                    for (let i = 0; i < distances.length; i++) {
                        if (!visited.has(i) && distances[i] < minDistance) {
                            minDistance = distances[i];
                            nextPoint = i;
                        }
                    }
                    
                    if (nextPoint === -1) break;
                    
                    visited.add(nextPoint);
                    order.push(nextPoint);
                }
                
                addLog('✓ Ordre optimal calculé');
                addLog(`Ordre des points : ${order.join(' → ')}`);
                
                // 3. Calculer l'itinéraire final
                addLog('Calcul de l\'itinéraire final...');
                const routeCoordinates = order.map(index => waypoints[index])
                    .map(wp => `${formatCoordinate(wp.lng)},${formatCoordinate(wp.lat)}`)
                    .join(';');
                
                const routeResponse = await fetch(`https://router.project-osrm.org/route/v1/driving/${routeCoordinates}?overview=full&geometries=geojson`);
                const routeData = await routeResponse.json();
                
                if (routeData.code === 'Ok') {
                    addLog(`Distance totale : ${(routeData.routes[0].distance / 1000).toFixed(1)} km`);
                    addLog(`Durée estimée : ${Math.round(routeData.routes[0].duration / 60)} minutes`);
                    return {
                        route: routeData.routes[0],
                        order: order
                    };
                } else {
                    throw new Error(`Erreur calcul itinéraire : ${routeData.code}`);
                }
            } catch (error) {
                addLog(`❌ Erreur : ${error.message}`);
                throw error;
            }
        }

        async function calculateRoutes() {
            const addresses = document.getElementById('addresses').value.split('\n').filter(addr => addr.trim());
            
            if (addresses.length === 0) {
                alert('Veuillez entrer au moins une adresse');
                return;
            }

            // Réinitialiser les logs
            document.getElementById('logContent').innerHTML = '';
            document.getElementById('logs').style.display = 'block';
            document.getElementById('results').style.display = 'none';

            addLog(`Début du calcul pour ${addresses.length} adresse(s)`);
            addLog(`Point de départ : ${MAMAMA_ADDRESS}`);

            try {
                // Géocoder toutes les adresses
                addLog('Recherche des coordonnées des adresses...');
                const locations = await Promise.all([
                    geocodeAddress(MAMAMA_ADDRESS),
                    ...addresses.map(addr => geocodeAddress(addr))
                ]);

                // Vérifier que toutes les adresses ont été trouvées
                const missingAddresses = locations.filter(loc => !loc);
                if (missingAddresses.length > 0) {
                    addLog(`❌ ${missingAddresses.length} adresse(s) non trouvée(s)`);
                    throw new Error('Certaines adresses n\'ont pas pu être trouvées');
                }

                // Créer la liste des points avec départ à MaMaMa (sans le point de retour)
                const waypoints = [locations[0], ...locations.slice(1)];
                addLog(`Liste des points à visiter (${waypoints.length} points) :`);
                waypoints.forEach((point, index) => {
                    addLog(`${index + 1}. ${point.address} (${point.lat}, ${point.lng})`);
                });

                // Calculer l'itinéraire optimisé
                const result = await calculateRoute(waypoints);

                // Afficher la liste des adresses dans l'ordre optimisé
                displayRoute(result.order.map(index => waypoints[index]));
            } catch (error) {
                console.error('Erreur:', error);
                addLog(`❌ Erreur : ${error.message}`);
                alert('Une erreur est survenue lors du calcul de l\'itinéraire. Veuillez vérifier que les adresses sont correctes.');
            }
        }

        function displayRoute(optimizedWaypoints) {
            const routesDiv = document.getElementById('routes');
            routesDiv.innerHTML = '';

            const routeDiv = document.createElement('div');
            routeDiv.className = 'route';
            routeDiv.innerHTML = `<h4>Itinéraire</h4><ol><li>${MAMAMA_ADDRESS}</li>`;
            
            optimizedWaypoints.slice(1).forEach(point => {
                routeDiv.innerHTML += `<li>${point.address}</li>`;
            });
            routeDiv.innerHTML += `<li>${MAMAMA_ADDRESS}</li></ol>`;
            
            routesDiv.appendChild(routeDiv);
            document.getElementById('results').style.display = 'block';
            addLog('✓ Itinéraire affiché');
        }

        document.getElementById('calculateButton').addEventListener('click', calculateRoutes);
    </script>
</body>
</html> 
